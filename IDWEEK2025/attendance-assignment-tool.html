<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDWeek 2025 - Attendance Assignments</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="header">
        <h1>IDWeek 2025 Assignments - <span style="font-size:24px;">October 19-22, 2025</span></h1>
    </div>

    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-number" id="total-sessions">0</div>
            <div class="stat-label">Sessions</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="total-users">0</div>
            <div class="stat-label">MSDs</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="total-assignments">0</div>
            <div class="stat-label">Assignments</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="conflicts-count">0</div>
            <div class="stat-label">Conflicts</div>
        </div>
    </div>

    <div class="controls">
        <div class="control-buttons">
            <input type="file" id="json-upload" accept=".json" style="display: none;">
            <button class="btn" onclick="document.getElementById('json-upload').click()">üìÅ Load Sessions JSON</button>
            <button class="btn" onclick="showAttendeesBySession()">üìã Attendees by Session</button>
            <button class="btn" onclick="showSessionsByAttendee()">üìÖ Sessions by Attendee</button>
            <button class="btn" onclick="exportAssignments()">üíæ Export Data</button>
            <button class="btn" onclick="generateReports()">üìä Generate Reports</button>
            <button class="btn" onclick="forceReload()">üîÑ Reload Data</button>
            <button class="btn btn-danger" onclick="clearAllData()">üóëÔ∏è Clear All</button>
        </div>
    </div>

    <div class="main-layout">
        <div class="panel">
            <div class="panel-header">
                <span>üë• Medical Science Directors</span>
                <button class="btn btn_header btn-sm" onclick="showAddUserModal()">+ Add</button>
            </div>
            <div class="panel-content">
                <div id="users-container">
                    <div class="no-data">No MSDs loaded yet.<br><button class="btn" onclick="showAddUserModal()">Add First MSD</button></div>
                </div>
            </div>
        </div>

        <div class="panel tabbed-panel">
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('sessions')" id="sessions-tab">
                    üìã Conference Sessions
                </button>
                <button class="tab-button" onclick="switchTab('calendar')" id="calendar-tab">
                    üìÖ Weekly Calendar View
                </button>
            </div>

            <!-- Sessions Tab Content -->
            <div id="sessions-tab-content" class="tab-content active">
                <div class="panel-header">
                    <span id="session-count">0 sessions</span>
                    <span><button class="btn_header" id="expand-collapse-all" onclick="toggleAllTimeSlots()">üìã Collapse All</button></span>
                </div>

                <div class="session-filters">
                    <input type="text" id="search-input" placeholder="üîç Search sessions, locations, speakers...">
                    <select id="date-filter">
                        <option value="">All Dates</option>
                    </select>
                    <select id="type-filter">
                        <option value="">All Types</option>
                    </select>
                    <button class="btn btn-sm" onclick="clearFilters()">Clear</button>
                </div>

                <div class="panel-content">
                    <div id="sessions-container">
                        <div class="loading">Loading sessions...</div>
                    </div>
                </div>
            </div>

            <!-- Calendar Tab Content -->
            <div id="calendar-tab-content" class="tab-content">
                <div class="panel-header">
                    <span id="calendar-summary">Loading calendar...</span>
                </div>
                <div class="calendar-view" id="calendar-container">
                    <!-- Calendar will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div id="user-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeUserModal()">&times;</span>
            <h2 style="color: #34495e; margin-bottom: 20px;">Add New Attendee</h2>
            
            <div class="form-group">
                <label>Full Name *</label>
                <input type="text" id="user-name" placeholder="Enter full name">
            </div>
            
            <div class="form-group">
                <label>Email Address *</label>
                <input type="email" id="user-email" placeholder="Enter email address">
            </div>
            
            <div class="form-group">
                <label>Department/Organization</label>
                <input type="text" id="user-department" placeholder="Enter department or organization">
            </div>
            
            <div class="form-group">
                <label>Role</label>
                <select id="user-role">
                    <option value="Attendee">Attendee</option>
                    <option value="Speaker">Speaker</option>
                    <option value="Staff">Staff</option>
                    <option value="VIP">VIP</option>
                    <option value="Moderator">Moderator</option>
                </select>
            </div>
            
            <div style="margin-top: 25px; text-align: right;">
                <button class="btn" onclick="closeUserModal()" style="margin-right: 10px; background: #6c757d;">Cancel</button>
                <button class="btn btn-success" onclick="saveUser()">Save User</button>
            </div>
        </div>
    </div>

    <!-- Attendees by Session Modal -->
    <div id="attendees-by-session-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeAttendeesBySessionModal()">&times;</span>
            <h2 style="color: #34495e; margin-bottom: 20px;">üìã Attendees by Session</h2>
            
            <input type="text" id="session-search" placeholder="üîç Search sessions..." style="margin-bottom: 15px;">
            
            <div id="attendees-by-session-content" style="max-height: 60vh; overflow-y: auto;">
                <!-- Content will be populated by JavaScript -->
            </div>
            
            <div style="margin-top: 25px; text-align: right;">
                <button class="btn" onclick="closeAttendeesBySessionModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Sessions by Attendee Modal -->
    <div id="sessions-by-attendee-modal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="closeSessionsByAttendeeModal()">&times;</span>
            <h2 style="color: #34495e; margin-bottom: 20px;">üìÖ Sessions by Attendee</h2>
            
            <input type="text" id="attendee-search" placeholder="üîç Search attendees..." style="margin-bottom: 15px;">
            
            <div id="sessions-by-attendee-content" style="max-height: 60vh; overflow-y: auto;">
                <!-- Content will be populated by JavaScript -->
            </div>
            
            <div style="margin-top: 25px; text-align: right;">
                <button class="btn" onclick="closeSessionsByAttendeeModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- MSD Assignments Modal -->
    <div id="msd-assignments-modal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="closeMSDAssignmentsModal()">&times;</span>
            <h2 id="msd-assignments-title" style="color: #34495e; margin-bottom: 20px;">üë®‚Äç‚öïÔ∏è MSD Assignments</h2>
            
            <div id="msd-assignments-content" style="max-height: 600px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                <!-- Content will be populated by JavaScript -->
            </div>
            
            <div style="margin-top: 25px; text-align: right;">
                <button class="btn" onclick="closeMSDAssignmentsModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global application state
        let sessions = [];
        let users = [];
        let msds = []; // Medical Science Directors data
        let assignments = {}; // sessionId -> [userIds]
        let selectedUser = null;
        let filteredSessions = [];

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Initializing IDWeek 2025 Attendance Tool...');
            setupEventHandlers();
            // Load MSD data first, then check for stored data
            loadMSDData();
            loadSessionsData();
        });

        function setupEventHandlers() {
            // File upload
            document.getElementById('json-upload').addEventListener('change', handleFileUpload);
            
            // Search and filters
            document.getElementById('search-input').addEventListener('input', filterSessions);
            document.getElementById('date-filter').addEventListener('change', filterSessions);
            document.getElementById('type-filter').addEventListener('change', filterSessions);
            
            // Modal controls
            window.addEventListener('click', function(event) {
                if (event.target.id === 'user-modal') {
                    closeUserModal();
                } else if (event.target.id === 'attendees-by-session-modal') {
                    closeAttendeesBySessionModal();
                } else if (event.target.id === 'sessions-by-attendee-modal') {
                    closeSessionsByAttendeeModal();
                } else if (event.target.id === 'duplicate-assignment-modal') {
                    cancelDuplicateAssignment();
                }
            });
        }

        function getConferenceId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('confid') || urlParams.get('conference_id') || '1'; // Default to 1 if not specified
        }

        function loadMSDData() {
            console.log('Loading Medical Science Directors from database...');
            const conferenceId = getConferenceId();
            console.log('üîç Using conference ID:', conferenceId);

            // Load conference users from database API
            console.log('üîç Attempting to fetch from:', `api_conference_users.cfm?confid=${conferenceId}&_t=${Date.now()}`);
            fetch(`api_conference_users.cfm?confid=${conferenceId}&_t=${Date.now()}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`‚úÖ Successfully loaded ${data.length} conference users from DATABASE`);
                    console.log('üîç Raw database users:', data);
                    msds = data;
                    // Pre-populate users with conference user data if users is empty
                    if (users.length === 0) {
                        users = msds.map(user => {
                            console.log('üîç Processing user:', user);
                            const mappedUser = {
                                id: user.USER_ID || user.user_id || user.id,
                                userId: user.USER_ID || user.user_id || user.id,
                                name: user.NAME || user.name || `${user.FIRSTNAME || user.firstname || ''} ${user.LASTNAME || user.lastname || ''}`.trim() || 'Unknown User',
                                firstname: user.FIRSTNAME || user.firstname || '',
                                lastname: user.LASTNAME || user.lastname || '',
                                email: user.EMAIL || user.email || '',
                                department: user.DEPARTMENT || user.department || 'Medical Affairs',
                                role: user.ROLE || user.role || user.TITLE || user.title || 'Medical Science Director',
                                title: user.TITLE || user.title || '',
                                degree: user.DEGREE || user.degree || '',
                                territory: user.TERRITORY || user.territory || '',
                                phone: user.PHONE || user.phone || '',
                                externalId: user.EXTERNAL_ID || user.external_id,
                                externalSystem: user.EXTERNAL_SYSTEM || user.external_system || '',
                                conferenceRole: user.CONFERENCE_ROLE || user.conference_role || 'msd',
                                active: user.ACTIVE || user.active,
                                createdAt: user.CREATED_AT || user.created_at || new Date().toISOString()
                            };
                            console.log('üîç Mapped user:', mappedUser);
                            return mappedUser;
                        });
                        console.log('‚úÖ Final users array:', users);
                        renderUsersMin();
                        updateStats();
                    }
                    showSuccessMessage(`Loaded ${msds.length} conference users!`);
                    
                    // Load stored assignments after MSDs are loaded
                    loadStoredData();
                })
                .catch(error => {
                    console.error('‚ùå Error loading conference users from database:', error);
                    console.error('‚ùå Error details:', {
                        message: error.message,
                        name: error.name,
                        stack: error.stack
                    });
                    alert('‚ùå Database API not available. Please start the API server.');
                    console.log('Falling back to local JSON file...');

                    // Fallback to JSON file if database is not available
                    return fetch('medical_science_directors.json')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('JSON fallback file not found');
                            }
                            return response.json();
                        })
                        .then(jsonData => {
                            console.log(`Loaded ${jsonData.length} users from JSON fallback`);
                            msds = jsonData;
                            if (users.length === 0) {
                                users = msds.map(msd => ({
                                    id: msd.melintaId || msd.id,
                                    userId: msd.melintaId || msd.id,
                                    name: msd.name,
                                    email: msd.email,
                                    department: msd.department || 'Medical Affairs',
                                    role: msd.role,
                                    title: msd.role,
                                    degree: msd.degree,
                                    territory: msd.territory,
                                    phone: msd.phone,
                                    externalId: msd.melintaId,
                                    externalSystem: 'melinta',
                                    conferenceRole: 'msd',
                                    active: true,
                                    createdAt: new Date().toISOString()
                                }));
                                renderUsersMin();
                                updateStats();
                            }
                            showSuccessMessage(`Loaded ${msds.length} users from JSON fallback`);
                            loadStoredData();
                        })
                        .catch(jsonError => {
                            console.error('Both database and JSON fallback failed:', jsonError);
                            console.log('Using hardcoded fallback data');

                            // Fallback MSD data
                            msds = [
                        {
                            "id": 3,
                            "melintaId": 3,
                            "name": "Besu Teshome, PharmD, MSc, BCPS",
                            "role": "Medical Science Director",
                            "email": "bteshome@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "South Central Ozarks",
                            "territories": ["Alabama", "Arkansas", "Kentucky", "Louisiana", "Mississippi", "Missouri", "Tennessee"]
                        },
                        {
                            "id": 4,
                            "melintaId": 4,
                            "name": "Christina Andrzejewski, PharmD, BCIDP",
                            "role": "Medical Science Director",
                            "email": "candrzejewski@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "Atlantic Capital",
                            "territories": ["Delaware", "District of Columbia", "Maryland", "North Carolina", "Ohio", "Pennsylvania", "Virginia", "West Virginia"]
                        },
                        {
                            "id": 5,
                            "melintaId": 5,
                            "name": "Erica Fernandez, PharmD, BCCCP, BCPS",
                            "role": "Medical Science Director",
                            "email": "efernandez@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "Midwest, North Central Ozarks",
                            "territories": ["Illinois", "Indiana", "Minnesota", "Missouri", "Nebraska", "Wisconsin"]
                        },
                        {
                            "id": 6,
                            "melintaId": 6,
                            "name": "Marianna Fedorenko, PharmD, BCPS, BCIDP",
                            "role": "Medical Science Director",
                            "email": "mfedorenko@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "NYC Metro, NJ",
                            "territories": ["New Jersey", "New York"]
                        },
                        {
                            "id": 7,
                            "melintaId": 7,
                            "name": "Michael North, PharmD, BCPS",
                            "role": "Medical Science Director",
                            "email": "mnorth@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "West",
                            "territories": ["Arizona", "California", "Colorado", "Nevada", "New Mexico", "Utah"]
                        },
                        {
                            "id": 8,
                            "melintaId": 8,
                            "name": "Ronak Gandhi, PharmD",
                            "role": "Medical Science Director",
                            "email": "rgandhi@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "New England & Upstate NY",
                            "territories": ["Connecticut", "Maine", "Massachusetts", "New Hampshire", "New York", "Rhode Island", "Vermont"]
                        },
                        {
                            "id": 2,
                            "melintaId": 2,
                            "name": "Saagar Akundi, BCPS, BCMAS",
                            "role": "Medical Science Director",
                            "email": "sakundi@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "South Central",
                            "territories": ["New Mexico", "Oklahoma", "Texas"]
                        },
                        {
                            "id": 1,
                            "melintaId": 1,
                            "name": "Sandy Estrada, PharmD, BCPS",
                            "role": "Senior Medical Science Director",
                            "email": "sestrada@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "Multiple Territories",
                            "territories": ["Alaska", "Hawaii", "Idaho", "Iowa", "Kansas", "Montana", "Nebraska", "New Mexico", "North Dakota", "Oregon", "Puerto Rico", "South Dakota", "Washington", "Wyoming"]
                        },
                        {
                            "id": 9,
                            "melintaId": 9,
                            "name": "Sarah Brooks Minor, PharmD, MHA, BCPS, BCIDP",
                            "role": "Medical Science Director",
                            "email": "sminor@melinta.com",
                            "department": "Medical Affairs",
                            "territory": "South Sunbelt",
                            "territories": ["Alabama", "Florida", "Georgia", "North Carolina", "South Carolina"]
                        }
                    ];
                    
                    // Always populate users with MSD data if users is empty
                    if (users.length === 0) {
                        users = msds.map(msd => ({
                            id: msd.melintaId,
                            melintaId: msd.melintaId,
                            name: msd.name,
                            email: msd.email,
                            department: msd.department || 'Medical Affairs',
                            role: msd.role,
                            territory: msd.territory,
                            territories: msd.territories,
                            createdAt: new Date().toISOString()
                        }));
                        console.log(`Pre-populated ${users.length} users from fallback MSD data`);
                        renderUsersMin();
                        updateStats();
                        saveToStorage(); // Save the new MSD data
                    }
                            showSuccessMessage(`Loaded ${msds.length} Medical Science Directors (fallback data)!`);

                            // Load stored assignments after MSDs are loaded
                            loadStoredData();
                        });
                });
        }

        function loadSessionsData() {
            console.log('Loading combined sessions and posters data...');

            // Load combined data file
            fetch('idweek2025_combined.json')
                .then(response => {
                    if (!response.ok) throw new Error('Combined data file not found');
                    return response.json();
                })
                .then(allSessions => {
                    console.log(`Successfully loaded ${allSessions.length} items`);

                    // Count different types
                    const typeCounts = {};
                    allSessions.forEach(item => {
                        const type = item.session_info?.type || 'Unknown';
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    });

                    console.log('Data breakdown:', typeCounts);
                    console.log('Sample item:', allSessions[0]);

                    if (allSessions.length === 0) {
                        document.getElementById('sessions-container').innerHTML = `
                            <div class="no-data">
                                <h3>No Data Found</h3>
                                <p>Could not load sessions or posters</p>
                                <button class="btn" onclick="document.getElementById('json-upload').click()">
                                    üìÅ Upload Sessions File
                                </button>
                            </div>
                        `;
                        return;
                    }

                    sessions = allSessions;
                    processSessionsData();
                    renderSessions();
                    updateStats();

                    const posterCount = typeCounts['Poster'] || 0;
                    const sessionCount = allSessions.length - posterCount;

                    let message = `Loaded ${allSessions.length} items total`;
                    if (sessionCount > 0 && posterCount > 0) {
                        message = `Loaded ${sessionCount} sessions + ${posterCount} posters (${allSessions.length} total)`;
                    } else if (sessionCount > 0) {
                        message = `Loaded ${sessionCount} sessions`;
                    } else if (posterCount > 0) {
                        message = `Loaded ${posterCount} posters`;
                    }

                    showSuccessMessage(message);
                })
                .catch(error => {
                    console.error('Failed to load combined data:', error);
                    console.error('Make sure idweek2025_combined.json exists and is valid JSON');
                    document.getElementById('sessions-container').innerHTML = `
                        <div class="no-data">
                            <h3>Error Loading Data</h3>
                            <p>Could not load idweek2025_combined.json</p>
                            <button class="btn" onclick="document.getElementById('json-upload').click()">
                                üìÅ Upload Sessions File
                            </button>
                        </div>
                    `;
                });
        }

        function processSessionsData() {
            console.log(`Processing ${sessions.length} sessions...`);
            
            // Deduplicate sessions based on title, date, time, and location
            const sessionMap = new Map();
            const duplicateGroups = new Map();
            
            sessions.forEach(session => {
                const key = createSessionKey(session);
                
                if (sessionMap.has(key)) {
                    // This is a duplicate - group with the first occurrence
                    if (!duplicateGroups.has(key)) {
                        duplicateGroups.set(key, [sessionMap.get(key)]);
                    }
                    duplicateGroups.get(key).push(session);
                } else {
                    // This is the first occurrence
                    sessionMap.set(key, session);
                }
            });
            
            // Replace sessions array with deduplicated sessions
            const originalCount = sessions.length;
            sessions = Array.from(sessionMap.values());
            
            // Merge assignments from duplicate sessions
            mergeAssignmentsFromDuplicates(duplicateGroups);
            
            console.log(`Deduplicated from ${originalCount} to ${sessions.length} sessions`);
            if (duplicateGroups.size > 0) {
                console.log(`Found ${duplicateGroups.size} session groups with duplicates`);
            }
            
            // Extract unique dates and session types for filters
            const dates = new Set();
            const types = new Set();

            sessions.forEach(session => {
                const date = session.schedule?.date;
                const type = session.session_info?.type;

                if (date) dates.add(date);
                if (type) types.add(type);
            });

            console.log('Unique types found:', Array.from(types));
            console.log('Total sessions processed:', sessions.length);
            
            // Populate date filter
            const dateFilter = document.getElementById('date-filter');
            dateFilter.innerHTML = '<option value="">All Dates</option>';
            // Sort dates chronologically, not alphabetically
            Array.from(dates).sort((a, b) => {
                const dateA = new Date(a);
                const dateB = new Date(b);
                return dateA - dateB;
            }).forEach(date => {
                dateFilter.innerHTML += `<option value="${date}">${formatDate(date)}</option>`;
            });
            
            // Populate type filter
            const typeFilter = document.getElementById('type-filter');
            typeFilter.innerHTML = '<option value="">All Types</option>';
            Array.from(types).sort().forEach(type => {
                typeFilter.innerHTML += `<option value="${type}">${type}</option>`;
            });
        }

        function createSessionKey(session) {
            // Create a unique key for deduplication based on core session properties
            const title = session.session_info?.title || '';
            const date = session.schedule?.date || '';
            const time = session.schedule?.time || '';
            const location = session.schedule?.location || '';
            const type = session.session_info?.type || '';
            
            return `${title}|||${date}|||${time}|||${location}|||${type}`;
        }

        function mergeAssignmentsFromDuplicates(duplicateGroups) {
            // When we have duplicate sessions, we need to merge assignments
            // The first session in each group becomes the "canonical" session
            duplicateGroups.forEach((sessionGroup, key) => {
                if (sessionGroup.length > 1) {
                    const canonicalSession = sessionGroup[0];
                    const canonicalId = canonicalSession.session_id;
                    
                    // Merge assignments from all duplicate sessions into the canonical one
                    for (let i = 1; i < sessionGroup.length; i++) {
                        const duplicateId = sessionGroup[i].session_id;
                        
                        if (assignments[duplicateId]) {
                            if (!assignments[canonicalId]) {
                                assignments[canonicalId] = [];
                            }
                            
                            // Add any users from the duplicate that aren't already assigned to canonical
                            assignments[duplicateId].forEach(userId => {
                                if (!assignments[canonicalId].includes(userId)) {
                                    assignments[canonicalId].push(userId);
                                }
                            });
                            
                            // Remove the duplicate assignment entry
                            delete assignments[duplicateId];
                        }
                    }
                }
            });
        }

        function formatDate(dateStr) {
            // Convert "Sunday, October 19, 2025" to "Sun Oct 19"
            if (!dateStr) return 'TBD';
            const parts = dateStr.split(', ');
            if (parts.length >= 2) {
                const day = parts[0].substring(0, 3);
                const monthDay = parts[1].split(' ');
                if (monthDay.length >= 2) {
                    return `${day} ${monthDay[0].substring(0, 3)} ${monthDay[1]}`;
                }
            }
            return dateStr;
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    sessions = data;
                    console.log(`Loaded ${sessions.length} sessions from file`);
                    processSessionsData();
                    renderSessions();
                    updateStats();
                    showSuccessMessage(`Successfully loaded ${sessions.length} sessions!`);
                } catch (error) {
                    showErrorMessage('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function filterSessions() {
            const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
            const dateFilter = document.getElementById('date-filter').value;
            const typeFilter = document.getElementById('type-filter').value;
            
            // First, filter by search and date to get available sessions
            let availableSessions = sessions.filter(session => {
                // Search filter
                if (searchTerm) {
                    const title = session.session_info?.title?.toLowerCase() || '';
                    const location = session.schedule?.location?.toLowerCase() || '';
                    const speakers = getSpeakerNames(session).toLowerCase();
                    
                    if (!title.includes(searchTerm) && 
                        !location.includes(searchTerm) && 
                        !speakers.includes(searchTerm)) {
                        return false;
                    }
                }
                
                // Date filter
                if (dateFilter && session.schedule?.date !== dateFilter) {
                    return false;
                }
                
                return true;
            });
            
            // Update type filter options based on available sessions
            updateTypeFilterOptions(availableSessions);
            
            // Apply type filter to get final results
            filteredSessions = availableSessions.filter(session => {
                // Type filter
                if (typeFilter && session.session_info?.type !== typeFilter) {
                    return false;
                }
                
                return true;
            });
            
            renderSessions();
        }
        
        function updateTypeFilterOptions(availableSessions) {
            const typeFilter = document.getElementById('type-filter');
            const currentValue = typeFilter.value;
            
            // Get unique types from available sessions
            const availableTypes = new Set();
            availableSessions.forEach(session => {
                const type = session.session_info?.type;
                if (type) availableTypes.add(type);
            });
            
            // Rebuild type filter options
            typeFilter.innerHTML = '<option value="">All Types</option>';
            Array.from(availableTypes).sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (currentValue === type) {
                    option.selected = true;
                }
                typeFilter.appendChild(option);
            });
            
            // If the previously selected type is no longer available, clear the selection
            if (currentValue && !availableTypes.has(currentValue)) {
                typeFilter.value = '';
            }
        }

        function getSpeakerNames(session) {
            const speakers = session.speakers || {};
            let names = [];
            
            if (typeof speakers === 'object') {
                Object.values(speakers).forEach(speakerList => {
                    if (Array.isArray(speakerList)) {
                        speakerList.forEach(speaker => {
                            if (speaker.name) names.push(speaker.name);
                        });
                    }
                });
            }
            
            return names.join(' ');
        }

        function renderSessions() {
            const container = document.getElementById('sessions-container');
            const sessionsToShow = filteredSessions.length > 0 ? filteredSessions : sessions;

            if (sessionsToShow.length === 0) {
                container.innerHTML = '<div class="no-data">No sessions match your filters.</div>';
                document.getElementById('session-count').textContent = '0 sessions';
                return;
            }

            container.innerHTML = '';

            // Group sessions by date, then time slots
            const dateGroups = groupSessions(sessionsToShow);

            dateGroups.forEach(dateGroup => {
                const dateEl = createDateGroupElement(dateGroup);
                container.appendChild(dateEl);
            });

            document.getElementById('session-count').textContent = `${sessionsToShow.length} sessions`;
        }

        function groupSessions(sessions) {
            console.log('Grouping sessions:', sessions.length);

            // First group by date
            const dateGroups = new Map();

            sessions.forEach(session => {
                const date = session.schedule?.date || 'TBD';

                if (!dateGroups.has(date)) {
                    dateGroups.set(date, []);
                }

                dateGroups.get(date).push(session);
            });

            const sortedDates = Array.from(dateGroups.keys()).sort((a, b) => {
                return parseDate(a) - parseDate(b);
            });
            console.log('Date groups (chronological):', sortedDates);

            // Create hierarchical structure: dates containing time slots
            const finalGroups = [];

            sortedDates.forEach(date => {
                const daySessions = dateGroups.get(date);
                const timeGroups = new Map();

                // Group sessions by time within this date
                daySessions.forEach(session => {
                    const time = session.schedule?.time || 'TBD';
                    const key = time;

                    if (!timeGroups.has(key)) {
                        timeGroups.set(key, {
                            time: time,
                            sessions: []
                        });
                    }

                    timeGroups.get(key).sessions.push(session);
                });

                // Sort time groups within each day by actual time
                const sortedTimeGroups = Array.from(timeGroups.values()).sort((a, b) => {
                    const timeA = parseTimeForSorting(a.time);
                    const timeB = parseTimeForSorting(b.time);
                    return timeA - timeB;
                });

                // Create date group with nested time slots
                const dateGroup = {
                    type: 'date',
                    date: date,
                    timeSlots: sortedTimeGroups,
                    totalSessions: daySessions.length
                };

                console.log(`Date ${date}: ${sortedTimeGroups.length} time slots, ${daySessions.length} total sessions`);
                finalGroups.push(dateGroup);
            });

            console.log('Final date groups created:', finalGroups.length);
            return finalGroups;
        }

        function parseDate(dateString) {
            if (!dateString || dateString === 'TBD') return new Date(0);

            // Handle format: "Monday, October 20, 2025"
            try {
                // Remove day name and parse
                const cleanDate = dateString.replace(/^\w+,\s*/, '');
                return new Date(cleanDate);
            } catch (e) {
                console.warn('Could not parse date:', dateString);
                return new Date(0);
            }
        }

        function parseTimeForSorting(timeString) {
            if (!timeString || timeString === 'TBD') return 0;

            // Extract start time from "8:00 AM - 12:15 PM" format
            const startTime = timeString.split(' - ')[0].trim();

            try {
                // Parse time like "8:00 AM"
                const [time, period] = startTime.split(' ');
                const [hours, minutes] = time.split(':').map(Number);

                let hour24 = hours;
                if (period === 'PM' && hours !== 12) hour24 += 12;
                if (period === 'AM' && hours === 12) hour24 = 0;

                // Return minutes since midnight for comparison
                return hour24 * 60 + (minutes || 0);
            } catch (e) {
                console.warn('Could not parse time:', timeString);
                return 0;
            }
        }

        function toggleDateGroup(headerElement) {
            const dateGroup = headerElement.closest('.date-group');
            const isCollapsed = dateGroup.classList.contains('collapsed');

            if (isCollapsed) {
                dateGroup.classList.remove('collapsed');
                headerElement.classList.remove('collapsed');
            } else {
                dateGroup.classList.add('collapsed');
                headerElement.classList.add('collapsed');
            }
        }

        function toggleTimeSlot(headerElement) {
            const timeSlotGroup = headerElement.closest('.time-slot-group');
            const isCollapsed = timeSlotGroup.classList.contains('collapsed');

            if (isCollapsed) {
                timeSlotGroup.classList.remove('collapsed');
                headerElement.classList.remove('collapsed');
            } else {
                timeSlotGroup.classList.add('collapsed');
                headerElement.classList.add('collapsed');
            }
        }

        function toggleAllTimeSlots() {
            const dateGroups = document.querySelectorAll('.date-group');
            const timeSlotGroups = document.querySelectorAll('.time-slot-group');
            const button = document.getElementById('expand-collapse-all');

            if (dateGroups.length === 0) return;

            // Check if any are expanded
            const hasExpanded = Array.from(dateGroups).some(group => !group.classList.contains('collapsed')) ||
                              Array.from(timeSlotGroups).some(group => !group.classList.contains('collapsed'));

            // Toggle date groups
            dateGroups.forEach(group => {
                const header = group.querySelector('.date-header');
                if (hasExpanded) {
                    // Collapse all
                    group.classList.add('collapsed');
                    header.classList.add('collapsed');
                } else {
                    // Expand all
                    group.classList.remove('collapsed');
                    header.classList.remove('collapsed');
                }
            });

            // Toggle time slot groups
            timeSlotGroups.forEach(group => {
                const header = group.querySelector('.time-slot-header');
                if (hasExpanded) {
                    // Collapse all
                    group.classList.add('collapsed');
                    header.classList.add('collapsed');
                } else {
                    // Expand all
                    group.classList.remove('collapsed');
                    header.classList.remove('collapsed');
                }
            });

            // Update button text
            button.textContent = hasExpanded ? 'üìã Expand All' : 'üìã Collapse All';
        }

        function createDateGroupElement(dateGroup) {
            const div = document.createElement('div');
            div.className = 'date-group';

            const totalAssignments = dateGroup.timeSlots.reduce((sum, timeSlot) => {
                return sum + timeSlot.sessions.reduce((sessionSum, session) => {
                    return sessionSum + (assignments[getSessionId(session)] || []).length;
                }, 0);
            }, 0);

            div.innerHTML = `
                <div class="date-header" onclick="toggleDateGroup(this)">
                    <div class="date-info">
                        <div class="date-caret">‚ñº</div>
                        <div class="date-title">üìÖ ${formatDate(dateGroup.date)}</div>
                    </div>
                    <div class="date-stats">
                        ${dateGroup.timeSlots.length} time slot(s) ‚Ä¢ ${dateGroup.totalSessions} session(s) ‚Ä¢ ${totalAssignments} assignment(s)
                    </div>
                </div>
                <div class="date-content">
                    ${dateGroup.timeSlots.map(timeSlot => createTimeSlotElement(timeSlot)).join('')}
                </div>
            `;

            return div;
        }

        function createTimeSlotElement(timeSlot) {
            const totalAssignments = timeSlot.sessions.reduce((sum, session) => {
                return sum + (assignments[getSessionId(session)] || []).length;
            }, 0);

            return `
                <div class="time-slot-group">
                    <div class="time-slot-header" onclick="toggleTimeSlot(this)">
                        <div class="time-slot-info">
                            <div class="time-slot-caret">‚ñº</div>
                            <div class="time-slot-time">üïê ${timeSlot.time}</div>
                        </div>
                        <div class="time-slot-stats">
                            ${timeSlot.sessions.length} session(s) ‚Ä¢ ${totalAssignments} assignment(s)
                        </div>
                    </div>
                    <div class="time-slot-content">
                        ${timeSlot.sessions.map(session => createGroupedSessionHTML(session, null)).join('')}
                    </div>
                </div>
            `;
        }

        function createGroupedSessionHTML(session, groupLocation) {
            const sessionAssignments = assignments[getSessionId(session)] || [];
            const assignedUsers = sessionAssignments.map(userId =>
                users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId))
            ).filter(Boolean);

            const conflicts = selectedUser ? getConflicts(selectedUser.id, session) : [];
            const hasConflict = selectedUser && !sessionAssignments.includes(selectedUser.id) && hasTimeConflict(selectedUser.id, session);

            // Use individual session location if different from group location
            const sessionLocation = session.schedule?.location || groupLocation || 'TBD';
            const showLocation = sessionLocation !== groupLocation;

            const hasAssignments = sessionAssignments.length > 0;
            return `
                <div class="grouped-session ${hasAssignments ? 'assigned' : 'unassigned'}" data-session-id="${getSessionId(session)}">
                    <div class="grouped-session-main">
                        <div class="grouped-session-title">${getSessionTitle(session)}</div>
                        <div class="grouped-session-meta">
                            ${showLocation ? `
                            <div class="grouped-session-meta-item">
                                <strong>üìç Location:</strong> ${sessionLocation}
                            </div>
                            ` : ''}
                            <div class="grouped-session-meta-item">
                                <strong>üìã Type:</strong> ${session.session_info?.type || 'General'}
                            </div>
                            <div class="grouped-session-meta-item">
                                <strong>üéØ Track:</strong> ${session.tracks?.primary_track || 'General'}
                            </div>
                            <div class="grouped-session-meta-item ${assignedUsers.length > 0 ? 'assigned' : ''}">
                                <strong>üë• Assigned:</strong> ${assignedUsers.length > 0 ? assignedUsers.map(user => user.name).join(', ') : 'None'}
                            </div>
                        </div>
                    </div>
                    <div class="grouped-session-controls">
                        ${selectedUser ? `
                            ${hasConflict ? `
                                <div class="conflict-popup">
                                    <button class="btn btn-sm" style="background: #ffc107; color: #333; border: 1px solid #f0ad4e;"
                                            onclick="toggleAssignment('${getSessionId(session)}', ${selectedUser.id})"
                                            onmouseenter="showConflictTooltip(event, '${selectedUser.name}', '${conflicts.join('|||')}')"
                                            onmouseleave="hideConflictTooltip()">
                                        ‚ö†Ô∏è Conflict
                                    </button>
                                </div>
                            ` : `
                                <button class="btn btn-sm ${sessionAssignments.includes(selectedUser.id) ? 'btn-danger' : 'btn-success'}"
                                        onclick="toggleAssignment('${getSessionId(session)}', ${selectedUser.id})">
                                    ${sessionAssignments.includes(selectedUser.id) ? '‚ûñ Remove' : '‚ûï Assign'}
                                </button>
                            `}
                        ` : '<span style="color: #999; font-size: 12px;">Select user to assign</span>'}
                    </div>
                </div>
            `;
        }

        function createSessionElement(session) {
            const div = document.createElement('div');
            const sessionAssignments = assignments[getSessionId(session)] || [];
            const hasAssignments = sessionAssignments.length > 0;
            div.className = `session-item ${hasAssignments ? 'assigned' : 'unassigned'}`;
            div.dataset.sessionId = getSessionId(session);

            const assignedUsers = sessionAssignments.map(userId =>
                users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId))
            ).filter(Boolean);

            const conflicts = selectedUser ? getConflicts(selectedUser.id, session) : [];
            const hasConflict = selectedUser && !sessionAssignments.includes(selectedUser.id) && hasTimeConflict(selectedUser.id, session);
            
            div.innerHTML = `
                <div class="session-header">
                    <div class="session-title">${getSessionTitle(session)}</div>
                    <div>
                        ${selectedUser ? `
                            <button class="btn btn-sm ${sessionAssignments.includes(selectedUser.id) ? 'btn-danger' : hasConflict ? 'btn' : 'btn-success'}" 
                                    onclick="toggleAssignment('${getSessionId(session)}', ${selectedUser.id})"
                                    ${hasConflict ? 'style="background: #ffc107; color: #333; border: 1px solid #f0ad4e;" title="‚ö†Ô∏è Time conflict - cannot attend multiple sessions simultaneously"' : ''}>
                                ${sessionAssignments.includes(selectedUser.id) ? '‚ûñ Remove' : hasConflict ? '‚ö†Ô∏è Conflict' : '‚ûï Assign'}
                            </button>
                        ` : '<span style="color: #999; font-size: 12px;">Select user to assign</span>'}
                    </div>
                </div>
                
                <div class="session-details">
                    <div class="session-meta">
                        <div class="meta-item">
                            <strong>üìÖ Date</strong>
                            ${formatDate(session.schedule?.date) || 'TBD'}
                        </div>
                        <div class="meta-item">
                            <strong>üïê Time</strong>
                            ${session.schedule?.time || 'TBD'}
                        </div>
                        <div class="meta-item">
                            <strong>üìç Location</strong>
                            ${session.schedule?.location || 'TBD'}
                        </div>
                        <div class="meta-item">
                            <strong>üìã Type</strong>
                            ${session.session_info?.type || 'General'}
                        </div>
                        <div class="meta-item">
                            <strong>üë• Assigned</strong>
                            ${assignedUsers.length} attendee(s)
                        </div>
                        <div class="meta-item">
                            <strong>üéØ Track</strong>
                            ${session.tracks?.primary_track || 'General'}
                        </div>
                    </div>
                    
                    ${assignedUsers.length > 0 ? `
                        <div class="attendee-list">
                            ${assignedUsers.map(user => `
                                <span class="attendee-tag">
                                    ${user.name}
                                    <button class="remove-attendee" onclick="removeAssignment(${getSessionId(session)}, ${user.id})" title="Remove ${user.name}">√ó</button>
                                </span>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${hasConflict ? `
                        <div class="conflict-warning" style="background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; font-weight: bold;">
                            üö´ TIME CONFLICT: ${selectedUser.name} is already assigned to overlapping session(s): ${conflicts.join(', ')}
                            <br><small style="font-weight: normal;">A person cannot attend multiple sessions at the same time.</small>
                        </div>
                    ` : conflicts.length > 0 ? `
                        <div class="conflict-warning">
                            ‚ö†Ô∏è Time conflict with: ${conflicts.join(', ')}
                        </div>
                    ` : ''}
                </div>
            `;

            return div;
        }

        function renderUsers() {
            const container = document.getElementById('users-container');
            
            if (users.length === 0) {
                container.innerHTML = `
                    <div class="no-data">
                        No attendees added yet.<br>
                        <button class="btn" onclick="showAddUserModal()">Add First User</button>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            users.forEach(user => {
                const userAssignments = getUserAssignments(user.id);
                const userConflicts = getUserConflicts(user.id);
                
                const div = document.createElement('div');
                div.className = `user-item ${selectedUser?.id === user.id ? 'selected' : ''}`;
                div.onclick = () => selectUser(user);
                
                // Create assignment count span with proper event handling
                const assignmentSpan = document.createElement('span');
                assignmentSpan.className = 'assignment-count';
                assignmentSpan.textContent = `${userAssignments.length} sessions`;
                assignmentSpan.title = 'Click to view assigned sessions';
                assignmentSpan.onclick = (event) => {
                    event.stopPropagation();
                    showMSDAssignments(user.id, event);
                };
                
                div.innerHTML = `
                    <div class="user-name">${user.name}</div>
                    <div class="user-email">${user.email}</div>
                    ${user.role ? `<div class="user-email">${user.role}</div>` : ''}
                    ${user.territory ? `<div class="user-email" style="font-size: 11px; color: #999;">${user.territory}</div>` : ''}
                    <div class="user-stats">
                        <span class="assignment-count-placeholder"></span>
                        ${userConflicts > 0 ? `‚Ä¢ ${userConflicts} conflicts` : ''}
                        ${user.melintaId ? `‚Ä¢ ID: ${user.melintaId}` : ''}
                    </div>
                `;
                
                // Replace the placeholder with the actual clickable element
                const placeholder = div.querySelector('.assignment-count-placeholder');
                placeholder.replaceWith(assignmentSpan);
                
                container.appendChild(div);
            });
        }

        function renderUsersMin() {
            const container = document.getElementById('users-container');

            if (users.length === 0) {
                container.innerHTML = `
                    <div class="no-data">
                        No attendees added yet.<br>
                        <button class="btn" onclick="showAddUserModal()">Add First User</button>
                    </div>
                `;
                return;
            }

            container.innerHTML = '';

            // Sort users alphabetically by last name
            const sortedUsers = [...users].sort((a, b) => {
                const nameA = a.name || a.firstname + ' ' + a.lastname || 'Unknown';
                const nameB = b.name || b.firstname + ' ' + b.lastname || 'Unknown';
                const lastNameA = nameA.split(' ').pop().toLowerCase();
                const lastNameB = nameB.split(' ').pop().toLowerCase();
                return lastNameA.localeCompare(lastNameB);
            });

            sortedUsers.forEach(user => {
                const userAssignments = getUserAssignments(user.id);
                const userConflicts = getUserConflicts(user.id);
                
                const div = document.createElement('div');
                div.className = `user-item ${selectedUser?.id === user.id ? 'selected' : ''}`;
                div.onclick = () => selectUser(user);
                
                // Create assignment count span with proper event handling
                const assignmentSpan = document.createElement('span');
                assignmentSpan.className = 'assignment-count';
                assignmentSpan.textContent = `${userAssignments.length} sessions`;
                assignmentSpan.title = 'Click to view assigned sessions';
                assignmentSpan.onclick = (event) => {
                    event.stopPropagation();
                    showMSDAssignments(user.id, event);
                };
                
                div.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                        <div class="user-name" title="${user.email || user.name}">${user.name}</div>
                        <span class="assignment-count-placeholder"></span>
                    </div>
                    ${userConflicts > 0 ? `<div class="user-stats" style="color: #dc3545; font-size: 11px;">${userConflicts} conflicts</div>` : ''}
                `;
                
                // Replace the placeholder with the actual clickable element
                const placeholder = div.querySelector('.assignment-count-placeholder');
                placeholder.replaceWith(assignmentSpan);
                
                container.appendChild(div);
            });
        }

        function selectUser(user) {
            selectedUser = user;

            // Force remove selected class from all user items first
            document.querySelectorAll('.user-item.selected').forEach(el => {
                el.classList.remove('selected');
            });

            renderUsersMin();
            renderSessions();
            console.log(`Selected user: ${user.name}`);
        }

        async function toggleAssignment(sessionId, userId) {
            if (!assignments[sessionId]) {
                assignments[sessionId] = [];
            }
            
            const index = assignments[sessionId].indexOf(userId);
            if (index === -1) {
                // Check for duplicate assignment to same session (unless it's a poster session)
                // Try multiple matching strategies due to type mismatches
                let newSession = sessions.find(s => s.session_id === sessionId);
                if (!newSession) {
                    newSession = sessions.find(s => s.session_id == sessionId);
                }
                if (!newSession) {
                    newSession = sessions.find(s => String(s.session_id) === String(sessionId));
                }
                const sessionType = newSession?.session_info?.type?.toLowerCase() || '';
                const isPosterSession = sessionType.includes('poster');
                
                if (!isPosterSession && assignments[sessionId] && assignments[sessionId].length > 0) {
                    const existingUser = users.find(u => u.id === assignments[sessionId][0]);
                    const shouldContinue = await showDuplicateAssignmentModal(
                        existingUser?.name || 'Unknown',
                        newSession?.session_info?.title || 'Unknown Session'
                    );

                    if (!shouldContinue) {
                        console.log(`Assignment blocked - session ${sessionId} already has an MSD assigned`);
                        return;
                    }
                }
                
                // Check for time conflicts before assigning
                if (newSession && hasTimeConflict(userId, newSession)) {
                    const conflictingSessions = getConflictingSessions(userId, newSession);
                    const conflictList = conflictingSessions.map(s => s.session_info?.title || `Session ${s.session_id}`).join('\n‚Ä¢ ');
                    
                    const shouldContinue = confirm(
                        `‚ö†Ô∏è TIME CONFLICT DETECTED\n\n` +
                        `This user is already assigned to overlapping session(s):\n‚Ä¢ ${conflictList}\n\n` +
                        `A person cannot be in two places at the same time.\n\n` +
                        `Do you want to proceed anyway? (Not recommended)`
                    );
                    
                    if (!shouldContinue) {
                        console.log(`Assignment blocked due to time conflict for user ${userId} and session ${sessionId}`);
                        return;
                    }
                }
                
                assignments[sessionId].push(userId);
                console.log(`Assigned user ${userId} to session ${sessionId}`);
            } else {
                assignments[sessionId].splice(index, 1);
                console.log(`Removed user ${userId} from session ${sessionId}`);
            }
            
            renderSessions();
            renderUsersMin();
            updateStats();
            saveToStorage();
        }

        function hasTimeConflict(userId, newSession) {
            const userSessions = getUserAssignments(userId);
            
            return userSessions.some(sessionId => {
                // Skip self-comparison with flexible matching
                if (sessionId === newSession.session_id || 
                    sessionId == newSession.session_id || 
                    String(sessionId) === String(newSession.session_id)) {
                    return false;
                }
                
                // Try multiple matching strategies due to type mismatches
                let existingSession = sessions.find(s => s.session_id === sessionId);
                if (!existingSession) {
                    existingSession = sessions.find(s => s.session_id == sessionId);
                }
                if (!existingSession) {
                    existingSession = sessions.find(s => String(s.session_id) === String(sessionId));
                }
                
                return existingSession && sessionsOverlap(newSession, existingSession);
            });
        }

        function getConflictingSessions(userId, newSession) {
            const userSessions = getUserAssignments(userId);
            const conflicting = [];
            
            userSessions.forEach(sessionId => {
                // Skip self-comparison with flexible matching
                if (sessionId === newSession.session_id || 
                    sessionId == newSession.session_id || 
                    String(sessionId) === String(newSession.session_id)) {
                    return;
                }
                
                // Try multiple matching strategies due to type mismatches
                let existingSession = sessions.find(s => s.session_id === sessionId);
                if (!existingSession) {
                    existingSession = sessions.find(s => s.session_id == sessionId);
                }
                if (!existingSession) {
                    existingSession = sessions.find(s => String(s.session_id) === String(sessionId));
                }
                
                if (existingSession && sessionsOverlap(newSession, existingSession)) {
                    conflicting.push(existingSession);
                }
            });
            
            return conflicting;
        }

        function removeAssignment(sessionId, userId) {
            if (assignments[sessionId]) {
                // Handle both string and number user IDs
                const index = assignments[sessionId].findIndex(id =>
                    id == userId || id === String(userId) || id === Number(userId)
                );
                if (index !== -1) {
                    assignments[sessionId].splice(index, 1);

                    // Clean up empty assignment arrays
                    if (assignments[sessionId].length === 0) {
                        delete assignments[sessionId];
                    }

                    console.log(`‚úÖ Removed assignment: User ${userId} from Session ${sessionId}`);
                    renderSessions();
                    renderUsersMin();
                    updateStats();
                    saveToStorage();
                }
            }
        }

        function getUserAssignments(userId) {
            const userAssignments = Object.keys(assignments).filter(sessionId => {
                // Check both string and number versions of userId
                return assignments[sessionId].includes(userId) ||
                       assignments[sessionId].includes(String(userId)) ||
                       assignments[sessionId].includes(Number(userId));
            });

            // Debug logging - temporarily enabled
            if (userId === 9 || userId === '9') {
                console.log(`üîç getUserAssignments(${userId}):`, {
                    userId: userId,
                    userIdType: typeof userId,
                    assignments: assignments,
                    userAssignments: userAssignments,
                    allAssignmentKeys: Object.keys(assignments),
                    allAssignmentValues: Object.values(assignments),
                    sampleAssignmentUserIds: Object.values(assignments).flat().slice(0, 10)
                });
            }

            return userAssignments;
        }

        function getUserConflicts(userId) {
            const userSessions = getUserAssignments(userId);
            let conflicts = 0;
            
            for (let i = 0; i < userSessions.length; i++) {
                // Try multiple matching strategies due to type mismatches
                let session1 = sessions.find(s => s.session_id === userSessions[i]);
                if (!session1) {
                    session1 = sessions.find(s => s.session_id == userSessions[i]);
                }
                if (!session1) {
                    session1 = sessions.find(s => String(s.session_id) === String(userSessions[i]));
                }
                if (!session1) continue;
                
                for (let j = i + 1; j < userSessions.length; j++) {
                    // Try multiple matching strategies due to type mismatches  
                    let session2 = sessions.find(s => s.session_id === userSessions[j]);
                    if (!session2) {
                        session2 = sessions.find(s => s.session_id == userSessions[j]);
                    }
                    if (!session2) {
                        session2 = sessions.find(s => String(s.session_id) === String(userSessions[j]));
                    }
                    if (!session2) continue;
                    
                    if (sessionsOverlap(session1, session2)) {
                        conflicts++;
                    }
                }
            }
            
            return conflicts;
        }

        function getConflicts(userId, newSession) {
            const userSessions = getUserAssignments(userId);
            const conflicts = [];
            
            userSessions.forEach(sessionId => {
                // Skip self-comparison with flexible matching
                if (sessionId === newSession.session_id || 
                    sessionId == newSession.session_id || 
                    String(sessionId) === String(newSession.session_id)) {
                    return;
                }
                
                // Try multiple matching strategies due to type mismatches
                let existingSession = sessions.find(s => s.session_id === sessionId);
                if (!existingSession) {
                    existingSession = sessions.find(s => s.session_id == sessionId);
                }
                if (!existingSession) {
                    existingSession = sessions.find(s => String(s.session_id) === String(sessionId));
                }
                
                if (existingSession && sessionsOverlap(newSession, existingSession)) {
                    conflicts.push(existingSession.session_info?.title || `Session ${sessionId}`);
                }
            });
            
            return conflicts;
        }

        function sessionsOverlap(session1, session2) {
            const date1 = session1.schedule?.date;
            const date2 = session2.schedule?.date;
            const time1 = session1.schedule?.time;
            const time2 = session2.schedule?.time;
            
            
            // If no date or time info, treat as potential conflict (be conservative)
            if (!date1 || !date2 || !time1 || !time2) {
                console.warn('Missing date/time data for conflict check:', {session1: session1.session_id, session2: session2.session_id});
                return false; // Don't block if we can't determine
            }
            
            // Different dates = no conflict
            if (date1 !== date2) {
                return false;
            }
            
            // Same date and exact same time string = definite conflict
            if (time1 === time2) {
                console.log('Exact time match conflict detected:', time1);
                return true;
            }
            
            // Parse time ranges (e.g., "8:00 AM - 12:00 PM" or "12:15 PM - 1:30 PM")
            const parseTime = (timeStr) => {
                // Handle both single times and ranges
                let match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)\s*-\s*(\d{1,2}):(\d{2})\s*(AM|PM)/);
                
                if (!match) {
                    // Try single time format (assume 1 hour duration)
                    match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/);
                    if (!match) {
                        console.warn('Unable to parse time format:', timeStr);
                        return null;
                    }
                    
                    let hour = parseInt(match[1]);
                    let min = parseInt(match[2]);
                    
                    if (match[3] === 'PM' && hour !== 12) hour += 12;
                    if (match[3] === 'AM' && hour === 12) hour = 0;
                    
                    const startMinutes = hour * 60 + min;
                    return {
                        start: startMinutes,
                        end: startMinutes + 60 // Assume 1 hour duration
                    };
                }
                
                // Parse range format
                let startHour = parseInt(match[1]);
                let startMin = parseInt(match[2]);
                let endHour = parseInt(match[4]);
                let endMin = parseInt(match[5]);
                
                if (match[3] === 'PM' && startHour !== 12) startHour += 12;
                if (match[3] === 'AM' && startHour === 12) startHour = 0;
                if (match[6] === 'PM' && endHour !== 12) endHour += 12;
                if (match[6] === 'AM' && endHour === 12) endHour = 0;
                
                return {
                    start: startHour * 60 + startMin,
                    end: endHour * 60 + endMin
                };
            };
            
            const t1 = parseTime(time1);
            const t2 = parseTime(time2);
            
            if (!t1 || !t2) {
                console.warn('Could not parse times for overlap check:', {time1, time2});
                return false; // Conservative: don't block if we can't parse
            }
            
            // Check for overlap: sessions overlap if one starts before the other ends
            const overlaps = t1.start < t2.end && t2.start < t1.end;
            
            if (overlaps) {
                console.log('Time overlap detected:', {
                    session1: `${session1.session_id} (${time1})`,
                    session2: `${session2.session_id} (${time2})`,
                    times: {t1, t2}
                });
            }
            
            return overlaps;
        }

        function showAddUserModal() {
            document.getElementById('user-modal').style.display = 'block';
            document.getElementById('user-name').focus();
        }

        function closeUserModal() {
            document.getElementById('user-modal').style.display = 'none';
            clearUserForm();
        }

        function clearUserForm() {
            document.getElementById('user-name').value = '';
            document.getElementById('user-email').value = '';
            document.getElementById('user-department').value = '';
            document.getElementById('user-role').value = 'Attendee';
        }

        function saveUser() {
            const name = document.getElementById('user-name').value.trim();
            const email = document.getElementById('user-email').value.trim();
            const department = document.getElementById('user-department').value.trim();
            const role = document.getElementById('user-role').value;
            
            if (!name) {
                showErrorMessage('Name is required');
                return;
            }
            
            if (!email) {
                showErrorMessage('Email is required');
                return;
            }
            
            // Check for duplicate email
            if (users.some(u => u.email.toLowerCase() === email.toLowerCase())) {
                showErrorMessage('A user with this email already exists');
                return;
            }
            
            const user = {
                id: Date.now(),
                name: name,
                email: email,
                department: department,
                role: role,
                createdAt: new Date().toISOString()
            };
            
            users.push(user);
            renderUsersMin();
            updateStats();
            saveToStorage();
            closeUserModal();
            
            showSuccessMessage(`Added ${name} as ${role}`);
            console.log('Added user:', user);
        }

        function clearFilters() {
            document.getElementById('search-input').value = '';
            document.getElementById('date-filter').value = '';
            document.getElementById('type-filter').value = '';
            filterSessions();
        }

        function updateStats() {
            document.getElementById('total-sessions').textContent = sessions.length;
            document.getElementById('total-users').textContent = users.length;
            
            const totalAssignments = Object.values(assignments).reduce((sum, userList) => sum + userList.length, 0);
            document.getElementById('total-assignments').textContent = totalAssignments;
            
            let totalConflicts = 0;
            users.forEach(user => {
                totalConflicts += getUserConflicts(user.id);
            });
            document.getElementById('conflicts-count').textContent = totalConflicts;
            
            // Update calendar
            renderCalendar();
        }

        function renderCalendar() {
            const container = document.getElementById('calendar-container');
            const summary = document.getElementById('calendar-summary');
            
            if (sessions.length === 0) {
                container.innerHTML = '<div class="no-data">No sessions available for calendar view.</div>';
                summary.textContent = 'No data';
                return;
            }

            // Group sessions by date, then by time slot
            const sessionsByDate = {};
            sessions.forEach(session => {
                const date = session.schedule?.date;
                if (date) {
                    if (!sessionsByDate[date]) {
                        sessionsByDate[date] = {};
                    }
                    const time = session.schedule?.time || 'Time TBD';
                    if (!sessionsByDate[date][time]) {
                        sessionsByDate[date][time] = [];
                    }
                    sessionsByDate[date][time].push(session);
                }
            });

            // Sort dates chronologically
            const sortedDates = Object.keys(sessionsByDate).sort((a, b) => {
                const dateA = new Date(a);
                const dateB = new Date(b);
                if (!isNaN(dateA.getTime()) && !isNaN(dateB.getTime())) {
                    return dateA - dateB;
                }
                return a.localeCompare(b);
            });

            if (sortedDates.length === 0) {
                container.innerHTML = '<div class="no-data">No sessions with dates available.</div>';
                summary.textContent = 'No scheduled sessions';
                return;
            }

            let calendarHTML = '';
            sortedDates.forEach(date => {
                console.log('Processing date:', date); // Debug log

                // Handle different date formats
                let dateObj;
                if (date.includes(',')) {
                    // Format like "Sunday, October 19, 2025"
                    dateObj = new Date(date);
                } else {
                    // Try adding time for parsing
                    dateObj = new Date(date + 'T00:00:00');
                }

                // Fallback if date parsing fails
                let dayName, dayNumber;
                if (isNaN(dateObj.getTime())) {
                    console.warn('Failed to parse date:', date);
                    dayName = date.split(',')[0] || 'Unknown Day';
                    dayNumber = date.split(' ')[2] || '?';
                } else {
                    dayName = dateObj.toLocaleDateString('en-US', { weekday: 'long' });
                    dayNumber = dateObj.getDate();
                }

                // Parse times for sorting
                const parseTime = (timeStr) => {
                    if (!timeStr || timeStr === 'TBD' || timeStr === 'Time TBD') return 0;
                    const match = timeStr.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (!match) return 0;
                    let hours = parseInt(match[1]);
                    const minutes = parseInt(match[2]);
                    const period = match[3].toUpperCase();
                    if (period === 'PM' && hours !== 12) hours += 12;
                    if (period === 'AM' && hours === 12) hours = 0;
                    return hours * 60 + minutes;
                };

                // Sort time slots chronologically
                const timeSlots = Object.keys(sessionsByDate[date]).sort((a, b) => {
                    return parseTime(a) - parseTime(b);
                });

                calendarHTML += `
                    <div class="day-column">
                        <div class="day-header">${dayName} ${dayNumber}</div>
                        <div class="day-content">
                `;

                timeSlots.forEach((timeSlot, index) => {
                    const sessionsInSlot = sessionsByDate[date][timeSlot];
                    const sessionCount = sessionsInSlot.length;
                    const assignedCount = sessionsInSlot.filter(session =>
                        assignments[getSessionId(session)] && assignments[getSessionId(session)].length > 0
                    ).length;

                    const isFirstTimeSlot = index === 0;
                    calendarHTML += `
                        <div class="time-slot-header cal ${isFirstTimeSlot ? 'first' : ''}">
                            <div style="font-weight: bold; margin-bottom: 4px;">${timeSlot}</div>
                            <div style="font-size: 11px; color: #666;">
                                ${sessionCount} session${sessionCount !== 1 ? 's' : ''}
                                ${assignedCount > 0 ? `‚Ä¢ ${assignedCount} assigned` : ''}
                            </div>
                        </div>
                    `;

                    // Add individual sessions under the time slot
                    sessionsInSlot.forEach(session => {
                        const sessionAssignments = assignments[getSessionId(session)] || [];
                        const assignedUsers = sessionAssignments.map(userId =>
                            users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId))
                        ).filter(Boolean);

                        const hasAssignments = assignedUsers.length > 0;
                        const title = session.session_info?.title || 'Untitled';
                        const location = session.schedule?.location || 'TBD';

                        calendarHTML += `
                            <div class="calendar-session ${hasAssignments ? 'assigned' : 'unassigned'}"
                                 onclick="switchTab('sessions')"
                                 title="${title} - ${location}">
                                <div style="font-size: 14px; font-weight: 600;">
                                    ${title.length > 60 ? title.substring(0, 60) + '...' : title}
                                </div>
                                <div style="font-size: 10px; color: #666; display: flex; justify-content: space-between; align-items: center;">
                                    <span>üìç ${location}</span>
                                    ${assignedUsers.length > 0 ?
                                        `<span style="font-size: 12px; font-weight: bold;">üë• ${assignedUsers.map(u => (u.name || u.firstname || 'Unknown').split(' ')[0]).join(', ')}</span>` :
                                        '<span style="font-size: 9px; color: #999;">‚ö™ Unassigned</span>'
                                    }
                                </div>
                            </div>
                        `;
                    });
                });

                calendarHTML += '</div></div>'; // Close day-content and day-column

            });

            container.innerHTML = calendarHTML;

            const assignedCount = sessions.filter(s => assignments[getSessionId(s)]?.length > 0).length;
            summary.textContent = `${assignedCount}/${sessions.length} sessions assigned`;
        }

        function scrollToSession(sessionId) {
            const sessionElements = document.querySelectorAll('.session-item');
            sessionElements.forEach(element => {
                if (element.dataset.sessionId === sessionId) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    element.style.boxShadow = '0 0 10px rgba(44, 90, 160, 0.5)';
                    setTimeout(() => {
                        element.style.boxShadow = '';
                    }, 2000);
                }
            });
        }

        function switchTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => content.classList.remove('active'));

            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => button.classList.remove('active'));

            // Show selected tab content
            const selectedTabContent = document.getElementById(tabName + '-tab-content');
            const selectedTabButton = document.getElementById(tabName + '-tab');

            if (selectedTabContent && selectedTabButton) {
                selectedTabContent.classList.add('active');
                selectedTabButton.classList.add('active');

                // If switching to calendar tab, refresh the calendar display
                if (tabName === 'calendar') {
                    renderCalendar();
                }
            }
        }


        function exportAssignments() {
            const exportData = {
                exportInfo: {
                    tool: 'IDWeek 2025 Attendance Assignments',
                    exportDate: new Date().toISOString(),
                    sessionCount: sessions.length,
                    userCount: users.length,
                    assignmentCount: Object.values(assignments).reduce((sum, arr) => sum + arr.length, 0)
                },
                sessions: sessions,
                users: users,
                assignments: assignments
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                type: 'application/json' 
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `idweek2025_assignments_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showSuccessMessage('Assignment data exported successfully!');
        }

        function generateReports() {
            if (users.length === 0) {
                showErrorMessage('No users to generate reports for');
                return;
            }
            
            let report = 'IDWeek 2025 - Assignment Report\n';
            report += '='.repeat(50) + '\n';
            report += `Generated: ${new Date().toLocaleDateString()}\n`;
            report += `Sessions: ${sessions.length} | Users: ${users.length} | Assignments: ${Object.values(assignments).reduce((sum, arr) => sum + arr.length, 0)}\n\n`;
            
            // User schedules
            report += 'INDIVIDUAL SCHEDULES\n';
            report += '-'.repeat(30) + '\n\n';
            
            users.forEach(user => {
                const userSessions = getUserAssignments(user.id)
                    .map(sessionId => sessions.find(s => s.session_id === sessionId))
                    .filter(Boolean)
                    .sort((a, b) => {
                        const dateA = new Date(a.schedule?.date || '2025-01-01');
                        const dateB = new Date(b.schedule?.date || '2025-01-01');
                        return dateA - dateB;
                    });
                
                report += `${user.name} (${user.email})\n`;
                if (user.department) report += `${user.department}\n`;
                report += `Role: ${user.role}\n`;
                report += `Sessions: ${userSessions.length}\n\n`;
                
                if (userSessions.length === 0) {
                    report += '  No sessions assigned\n\n';
                } else {
                    userSessions.forEach(session => {
                        report += `  ‚Ä¢ ${session.session_info?.title || 'Untitled'}\n`;
                        report += `    ${formatDate(session.schedule?.date)} | ${session.schedule?.time || 'TBD'}\n`;
                        report += `    üìç ${session.schedule?.location || 'TBD'}\n\n`;
                    });
                }
                
                report += '\n';
            });
            
            // Session attendance
            report += '\n\nSESSION ATTENDANCE\n';
            report += '-'.repeat(30) + '\n\n';
            
            const sessionsWithAttendees = sessions.filter(session => 
                assignments[getSessionId(session)] && assignments[getSessionId(session)].length > 0
            ).sort((a, b) => {
                const dateA = new Date(a.schedule?.date || '2025-01-01');
                const dateB = new Date(b.schedule?.date || '2025-01-01');
                return dateA - dateB;
            });
            
            sessionsWithAttendees.forEach(session => {
                const sessionAssignments = assignments[getSessionId(session)] || [];
                const assignedUsers = sessionAssignments.map(userId =>
                    users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId))
                ).filter(Boolean).sort((a, b) => {
                    // Sort by lastname alphabetically
                    const lastNameA = a.lastname || a.name?.split(' ').pop() || '';
                    const lastNameB = b.lastname || b.name?.split(' ').pop() || '';
                    return lastNameA.localeCompare(lastNameB);
                });
                
                report += `${session.session_info?.title || 'Untitled'}\n`;
                report += `${formatDate(session.schedule?.date)} | ${session.schedule?.time || 'TBD'}\n`;
                report += `üìç ${session.schedule?.location || 'TBD'}\n`;
                report += `Attendees (${assignedUsers.length}):\n`;
                
                assignedUsers.forEach(user => {
                    report += `  ‚Ä¢ ${user.name} (${user.email}) - ${user.role}\n`;
                });
                
                report += '\n';
            });
            
            // Download report
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `idweek2025_report_${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            showSuccessMessage('Report generated and downloaded!');
        }

        function forceReload() {
            console.log('üîÑ Force reloading all data from database...');
            // Clear cached data
            users = [];
            assignments = {};
            selectedUser = null;
            // Clear localStorage
            localStorage.removeItem('idweek2025_tool_data');
            // Force reload from database
            loadMSDData();
            showSuccessMessage('Data reloaded from database');
        }

        function clearAllData() {
            if (confirm('‚ö†Ô∏è This will remove ALL users and assignments. Are you sure?')) {
                users = [];
                assignments = {};
                selectedUser = null;
                localStorage.removeItem('idweek2025_tool_data');
                renderUsersMin();
                renderSessions();
                updateStats();
                // Trigger MSD data reload
                loadMSDData();
                showSuccessMessage('All data cleared - MSDs will reload automatically');
            }
        }

        function saveToStorage() {
            // Save assignments to database
            const assignmentData = Object.keys(assignments).map(sessionId =>
                assignments[sessionId].map(userId => ({
                    session_id: sessionId,
                    user_id: userId
                }))
            ).flat();

            console.log('üíæ Saving assignments to database:', {
                conferenceId: getConferenceId(),
                assignmentCount: assignmentData.length,
                assignments: assignmentData
            });

            fetch(`api_assignments.cfm?confid=${getConferenceId()}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ assignments: assignmentData })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('‚úÖ Assignments saved to database successfully:', data);
                if (data.count !== undefined) {
                    showSuccessMessage(`Saved ${data.count} assignments to database`);
                }
            })
            .catch(error => {
                console.error('Error saving assignments to database:', error);
                // Fallback to localStorage
                try {
                    const fallbackData = {
                        users: users,
                        assignments: assignments,
                        selectedUserId: selectedUser?.id,
                        lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('idweek2025_tool_data', JSON.stringify(fallbackData));
                    console.log('Fallback: Data saved to localStorage');
                } catch (localError) {
                    console.error('Error saving to localStorage fallback:', localError);
                }
            });
        }

        function loadStoredData() {
            // Load assignments from database
            console.log('üì• Loading assignments from database for conference ID:', getConferenceId());
            fetch(`api_assignments.cfm?confid=${getConferenceId()}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('‚úÖ Loaded assignments from database:', data);
                    console.log('üîç Raw assignments data:', data.assignments);

                    // Convert database format to frontend format
                    assignments = data.assignments || {};

                    console.log('üîç Processed assignments object:', assignments);

                    const assignmentCount = Object.values(assignments).reduce((sum, arr) => sum + arr.length, 0);
                    console.log(`üìä Assignment summary: ${Object.keys(assignments).length} sessions with ${assignmentCount} total assignments`);

                    if (users.length > 0) {
                        console.log(`Using ${users.length} MSDs, loaded ${assignmentCount} assignments from database`);
                        // Force re-render to show assignment counts in left panel
                        renderUsersMin();
                        updateStats();
                        renderSessions();
                        // Re-render users again to ensure assignment counts are displayed
                        setTimeout(() => {
                            console.log('üîÑ Re-rendering users to show assignment counts...');
                            renderUsersMin();
                            updateStats();
                        }, 100);
                        if (assignmentCount > 0) {
                            showSuccessMessage(`Loaded ${assignmentCount} assignments from database`);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading assignments from database:', error);
                    console.log('Falling back to localStorage...');

                    // Fallback to localStorage
                    try {
                        const stored = localStorage.getItem('idweek2025_tool_data');
                        if (stored) {
                            const data = JSON.parse(stored);

                            // Load assignments (but preserve MSDs if already loaded)
                            assignments = data.assignments || {};

                            // Only override users if we don't already have MSDs loaded
                            if (users.length === 0 && data.users && data.users.length > 0) {
                                users = data.users;
                                console.log(`Loaded ${users.length} users from localStorage fallback`);
                                renderUsersMin();
                                updateStats();
                            } else if (users.length > 0) {
                                // We have MSDs loaded, just update assignments and re-render
                                console.log(`Using ${users.length} MSDs, loading ${Object.keys(assignments).length} assignments from localStorage fallback`);
                                if (data.selectedUserId) {
                                    selectedUser = users.find(u => u.id === data.selectedUserId);
                                }
                                renderUsersMin();
                                updateStats();
                            }
                        }
                    } catch (localError) {
                        console.error('Error loading from localStorage fallback:', localError);
                    }
                });
        }

        function showSuccessMessage(message) {
            // Simple alert for now - could be enhanced with toast notifications
            console.log('‚úÖ ' + message);
        }

        function showErrorMessage(message) {
            alert('‚ùå ' + message);
            console.error('‚ùå ' + message);
        }

        function getSessionTitle(session) {
            // For poster sessions, title is in presentation_details.title
            // For regular sessions, title is in session_info.title
            return session.presentation_details?.title || session.session_info?.title || 'Untitled Session';
        }

        function getSessionId(session) {
            // For poster sessions, use presentation_details.id as session ID
            // For regular sessions, use session_id
            return session.session_id || session.presentation_details?.id || 'unknown';
        }

        function findSessionById(sessionId) {
            // Try multiple matching strategies for both regular and poster sessions
            let session = sessions.find(s => s.session_id === sessionId);
            if (!session) {
                session = sessions.find(s => s.session_id == sessionId);
            }
            if (!session) {
                session = sessions.find(s => String(s.session_id) === String(sessionId));
            }
            // Also check poster sessions by presentation_details.id
            if (!session) {
                session = sessions.find(s => s.presentation_details?.id === sessionId);
            }
            if (!session) {
                session = sessions.find(s => String(s.presentation_details?.id) === String(sessionId));
            }
            return session;
        }

        function showAttendeesBySession() {
            if (sessions.length === 0) {
                showErrorMessage('No sessions loaded yet');
                return;
            }
            
            document.getElementById('attendees-by-session-modal').style.display = 'block';
            renderAttendeesBySession();
            
            // Add search functionality
            document.getElementById('session-search').oninput = function() {
                renderAttendeesBySession(this.value.toLowerCase());
            };
        }

        function closeAttendeesBySessionModal() {
            document.getElementById('attendees-by-session-modal').style.display = 'none';
        }

        function renderAttendeesBySession(searchTerm = '') {
            const container = document.getElementById('attendees-by-session-content');
            
            // Get sessions with attendees assigned
            const sessionsWithAttendees = sessions.filter(session => {
                const hasAttendees = assignments[getSessionId(session)] && assignments[getSessionId(session)].length > 0;
                const matchesSearch = searchTerm === '' || 
                    session.session_info?.title?.toLowerCase().includes(searchTerm) ||
                    session.schedule?.location?.toLowerCase().includes(searchTerm);
                return hasAttendees && matchesSearch;
            }).sort((a, b) => {
                const dateA = new Date(a.schedule?.date || '2025-01-01');
                const dateB = new Date(b.schedule?.date || '2025-01-01');
                return dateA - dateB;
            });

            if (sessionsWithAttendees.length === 0) {
                container.innerHTML = '<div class="no-data">No sessions with attendees found.</div>';
                return;
            }

            let html = '';
            sessionsWithAttendees.forEach(session => {
                const sessionAssignments = assignments[getSessionId(session)] || [];
                const assignedUsers = sessionAssignments.map(userId =>
                    users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId))
                ).filter(Boolean).sort((a, b) => {
                    // Sort by lastname alphabetically
                    const lastNameA = a.lastname || a.name?.split(' ').pop() || '';
                    const lastNameB = b.lastname || b.name?.split(' ').pop() || '';
                    return lastNameA.localeCompare(lastNameB);
                });

                html += `
                    <div style="border: 1px solid #e9ecef; border-radius: 8px; margin-bottom: 15px; padding: 15px;">
                        <h3 style="color: #2c5aa0; margin-bottom: 10px; font-size: 16px;">
                            ${getSessionTitle(session)}
                        </h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 10px; font-size: 13px; color: #666;">
                            <div><strong>üìÖ Date:</strong> ${formatDate(session.schedule?.date) || 'TBD'}</div>
                            <div><strong>üïê Time:</strong> ${session.schedule?.time || 'TBD'}</div>
                            <div><strong>üìç Location:</strong> ${session.schedule?.location || 'TBD'}</div>
                            <div><strong>üë• Attendees:</strong> ${assignedUsers.length}</div>
                        </div>
                        <div style="margin-top: 10px;">
                            <strong style="color: #333;">Attendees:</strong>
                            <div style="margin-top: 8px;">
                                ${assignedUsers.map(user => `
                                    <div style="padding: 8px; background: #f8f9fa; border-radius: 6px; margin-bottom: 5px; border-left: 3px solid #2c5aa0;">
                                        <strong>${user.name}</strong> (${user.role})
                                        <br><span style="font-size: 12px; color: #666;">${user.email}</span>
                                        ${user.department ? `<br><span style="font-size: 12px; color: #666;">${user.department}</span>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function showSessionsByAttendee() {
            if (users.length === 0) {
                showErrorMessage('No attendees added yet');
                return;
            }
            
            document.getElementById('sessions-by-attendee-modal').style.display = 'block';
            renderSessionsByAttendee();
            
            // Add search functionality
            document.getElementById('attendee-search').oninput = function() {
                renderSessionsByAttendee(this.value.toLowerCase());
            };
        }

        function closeSessionsByAttendeeModal() {
            document.getElementById('sessions-by-attendee-modal').style.display = 'none';
        }

        function showMSDAssignments(userId, event) {
            event.stopPropagation(); // Prevent user selection when clicking assignment count
            
            const user = users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId));
            if (!user) return;
            
            const modal = document.getElementById('msd-assignments-modal');
            const title = document.getElementById('msd-assignments-title');
            const content = document.getElementById('msd-assignments-content');
            
            title.textContent = `üë®‚Äç‚öïÔ∏è ${user.name} - Assigned Sessions`;
            
            // Check if sessions are still loading
            if (sessions.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">‚è≥ Loading sessions data... Please wait.</p>';
                modal.style.display = 'block';
                
                // Wait for sessions to load, then try again
                const checkInterval = setInterval(() => {
                    if (sessions.length > 0) {
                        clearInterval(checkInterval);
                        // Re-call this function now that sessions are loaded
                        showMSDAssignments(userId, {stopPropagation: () => {}});
                    }
                }, 500);
                return;
            }
            
            const userAssignments = getUserAssignments(userId);
            
            // DEBUG: Show what we're looking for vs what exists
            console.log('=== DEBUGGING SESSION LOOKUP ===');
            console.log('User assignments:', userAssignments);
            console.log('Total sessions in array:', sessions.length);
            console.log('First 10 session IDs in array:', sessions.slice(0, 10).map(s => ({id: s.session_id, type: typeof s.session_id})));
            console.log('Sample session titles:', sessions.slice(0, 5).map(s => s.session_info?.title?.substring(0, 50)));
            
            // Check each assignment individually
            userAssignments.forEach(assignedId => {
                console.log(`\nLooking for session ID: "${assignedId}" (type: ${typeof assignedId})`);
                const exactMatch = sessions.find(s => s.session_id === assignedId);
                const looseMatch = sessions.find(s => s.session_id == assignedId);
                const stringMatch = sessions.find(s => String(s.session_id) === String(assignedId));
                const posterMatch = sessions.find(s => s.presentation_details?.id === assignedId);
                const posterStringMatch = sessions.find(s => String(s.presentation_details?.id) === String(assignedId));
                const findByIdMatch = findSessionById(assignedId);

                console.log(`  Exact match (===): ${!!exactMatch}`);
                console.log(`  Loose match (==): ${!!looseMatch}`);
                console.log(`  String match: ${!!stringMatch}`);
                console.log(`  Poster match: ${!!posterMatch}`);
                console.log(`  Poster string match: ${!!posterStringMatch}`);
                console.log(`  findSessionById match: ${!!findByIdMatch}`);

                if (exactMatch) console.log(`  Found: ${exactMatch.session_info?.title}`);
                if (looseMatch && !exactMatch) console.log(`  Loose found: ${looseMatch.session_info?.title} (ID: ${looseMatch.session_id}, type: ${typeof looseMatch.session_id})`);
                if (posterMatch) console.log(`  Poster found: ${posterMatch.presentation_details?.title} (ID: ${posterMatch.presentation_details?.id})`);
                if (findByIdMatch) console.log(`  Helper found: ${getSessionTitle(findByIdMatch)}`);
            });
            
            // Separate found sessions from missing ones
            const foundSessions = [];
            const missingSessions = [];
            
            userAssignments.forEach(sessionId => {
                const session = findSessionById(sessionId);

                if (session) {
                    foundSessions.push(session);
                } else {
                    missingSessions.push(sessionId);
                }
            });
            
            if (userAssignments.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #666; padding: 40px;">No sessions assigned to this MSD.</p>';
            } else {
                // Sort found sessions by date and time
                foundSessions.sort((a, b) => {
                    const dateA = new Date(a.schedule?.date || '2025-01-01');
                    const dateB = new Date(b.schedule?.date || '2025-01-01');
                    if (dateA.getTime() !== dateB.getTime()) {
                        return dateA - dateB;
                    }
                    // If same date, sort by time
                    const timeA = a.schedule?.time || '';
                    const timeB = b.schedule?.time || '';
                    return timeA.localeCompare(timeB);
                });
                
                let html = `<div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Total Assignments: ${userAssignments.length}</strong>
                    ${foundSessions.length !== userAssignments.length ? 
                        `<br><span style="color: #dc3545; font-size: 12px;">‚ö†Ô∏è ${foundSessions.length} found, ${missingSessions.length} missing/conflicted</span>` : 
                        ''
                    }
                </div>`;
                
                // Show found sessions first
                foundSessions.forEach((session, index) => {
                    const conflicts = getConflictingSessions(userId, session);
                    const hasConflict = conflicts.length > 0;
                    
                    html += `
                        <div style="border: 1px solid #ddd; border-radius: 6px; padding: 15px; margin-bottom: 10px; ${hasConflict ? 'border-color: #dc3545; background: #fff5f5;' : 'background: white;'}">
                            <div style="display: flex; justify-content: between; align-items: flex-start; margin-bottom: 8px;">
                                <h4 style="color: #2c5aa0; margin: 0; flex: 1;">${getSessionTitle(session)}</h4>
                                <button onclick="removeAssignment('${getSessionId(session)}', ${userId})" 
                                    style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;">
                                    Remove
                                </button>
                            </div>
                            
                            <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                                <strong>üìÖ ${session.schedule?.date || 'Date TBD'}</strong> ‚Ä¢ 
                                <strong>‚è∞ ${session.schedule?.time || 'Time TBD'}</strong> ‚Ä¢ 
                                <strong>üìç ${session.schedule?.location || 'Location TBD'}</strong>
                            </div>
                            
                            ${session.session_info?.type ? `<div style="display: inline-block; background: #e9ecef; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-bottom: 8px;">${session.session_info.type}</div>` : ''}
                            
                            ${session.session_info?.description ? `<p style="font-size: 13px; color: #333; margin: 8px 0;">${session.session_info.description}</p>` : ''}
                            
                            ${hasConflict ? `
                                <div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 8px; border-radius: 4px; font-size: 12px; margin-top: 8px;">
                                    ‚ö†Ô∏è <strong>Time Conflict:</strong> This session conflicts with ${conflicts.length} other assigned session(s)
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
                
                // Show missing/conflicted sessions
                if (missingSessions.length > 0) {
                    html += `<div style="margin-top: 20px; margin-bottom: 15px;">
                        <h4 style="color: #dc3545; margin-bottom: 10px;">‚ö†Ô∏è Missing/Conflicted Assignments (${missingSessions.length})</h4>
                        <p style="font-size: 12px; color: #666; margin-bottom: 15px;">These assignments exist but the sessions cannot be found. They may have been removed or changed.</p>
                    </div>`;
                    
                    missingSessions.forEach(sessionId => {
                        html += `
                            <div style="border: 1px solid #dc3545; border-radius: 6px; padding: 15px; margin-bottom: 10px; background: #fff5f5;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                                    <h4 style="color: #dc3545; margin: 0; flex: 1;">‚ö†Ô∏è Session ID: ${sessionId}</h4>
                                    <button onclick="removeAssignment('${sessionId}', ${userId})" 
                                        style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 12px; cursor: pointer;"
                                        title="Remove this missing assignment">
                                        Remove
                                    </button>
                                </div>
                                
                                <div style="font-size: 13px; color: #721c24; margin-bottom: 8px;">
                                    <strong>Status:</strong> Session not found in current data
                                </div>
                                
                                <div style="background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; padding: 8px; border-radius: 4px; font-size: 12px;">
                                    This assignment references a session that no longer exists or has been changed. 
                                    You should remove this assignment or verify the session still exists.
                                </div>
                            </div>
                        `;
                    });
                }
                
                content.innerHTML = html;
            }
            
            modal.style.display = 'block';
        }

        function closeMSDAssignmentsModal() {
            document.getElementById('msd-assignments-modal').style.display = 'none';
        }

        function removeAssignment(sessionId, userId) {
            if (!assignments[sessionId]) return;

            // Handle both string and number user IDs
            const index = assignments[sessionId].findIndex(id =>
                id == userId || id === String(userId) || id === Number(userId)
            );
            if (index !== -1) {
                assignments[sessionId].splice(index, 1);

                // Clean up empty assignment arrays
                if (assignments[sessionId].length === 0) {
                    delete assignments[sessionId];
                }

                console.log(`‚úÖ Removed assignment: User ${userId} from Session ${sessionId}`);
                renderUsersMin();
                renderSessions();
                updateStats();
                saveToStorage();

                // Re-open the modal to show updated assignments
                const user = users.find(u => u.id == userId || u.id === String(userId) || u.id === Number(userId));
                if (user) {
                    showMSDAssignments(userId, {stopPropagation: () => {}});
                }
            }
        }

        function renderSessionsByAttendee(searchTerm = '') {
            const container = document.getElementById('sessions-by-attendee-content');
            
            // Get all users (filter by search term, show assignment counts)
            const filteredUsers = users.filter(user => {
                const matchesSearch = searchTerm === '' ||
                    user.name.toLowerCase().includes(searchTerm) ||
                    user.email.toLowerCase().includes(searchTerm) ||
                    (user.department && user.department.toLowerCase().includes(searchTerm));
                return matchesSearch;
            }).sort((a, b) => {
                // Sort by lastname alphabetically
                const lastNameA = a.lastname || a.name?.split(' ').pop() || '';
                const lastNameB = b.lastname || b.name?.split(' ').pop() || '';
                return lastNameA.localeCompare(lastNameB);
            });

            if (filteredUsers.length === 0) {
                container.innerHTML = '<div class="no-data">No attendees found.</div>';
                return;
            }

            let html = '';
            filteredUsers.forEach(user => {
                const userSessionIds = getUserAssignments(user.id);

                const userSessions = userSessionIds
                    .map(sessionId => findSessionById(sessionId))
                    .filter(Boolean)
                    .sort((a, b) => {
                        const dateA = new Date(a.schedule?.date || '2025-01-01');
                        const dateB = new Date(b.schedule?.date || '2025-01-01');
                        return dateA - dateB;
                    });

                const userConflicts = getUserConflicts(user.id);

                html += `
                    <div style="border: 1px solid #e9ecef; border-radius: 8px; margin-bottom: 15px; padding: 15px;">
                        <div style="display: flex; justify-content: between; align-items: flex-start; margin-bottom: 10px;">
                            <div>
                                <h3 style="color: #2c5aa0; margin-bottom: 5px; font-size: 16px;">${user.name}</h3>
                                <div style="font-size: 13px; color: #666;">
                                    <div>${user.email} ‚Ä¢ ${user.conference_role || 'msd'}</div>
                                    ${user.department ? `<div>${user.department}</div>` : ''}
                                    <div style="margin-top: 5px;">
                                        <strong>${userSessions.length} sessions assigned</strong>
                                        ${userConflicts > 0 ? `<span style="color: #dc3545;"> ‚Ä¢ ${userConflicts} conflicts</span>` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 10px;">
                            <strong style="color: #333;">Assigned Sessions:</strong>
                            <div style="margin-top: 8px;">
                                ${userSessions.map(session => `
                                    <div style="padding: 8px; background: #f8f9fa; border-radius: 6px; margin-bottom: 5px; border-left: 3px solid #2c5aa0;">
                                        <strong>${getSessionTitle(session)}</strong>
                                        <br><span style="font-size: 12px; color: #666;">
                                            üìÖ ${formatDate(session.schedule?.date) || 'TBD'} ‚Ä¢ 
                                            üïê ${session.schedule?.time || 'TBD'} ‚Ä¢ 
                                            üìç ${session.schedule?.location || 'TBD'}
                                        </span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Global tooltip element
        let globalTooltip = null;

        function createGlobalTooltip() {
            if (globalTooltip) return globalTooltip;

            globalTooltip = document.createElement('div');
            globalTooltip.style.position = 'fixed';
            globalTooltip.style.zIndex = '1000';
            globalTooltip.style.visibility = 'hidden';
            globalTooltip.style.opacity = '0';
            globalTooltip.style.pointerEvents = 'none';
            globalTooltip.style.transition = 'opacity 0.3s, transform 0.3s';
            globalTooltip.style.transform = 'translateY(-10px)';
            globalTooltip.style.maxWidth = '300px';
            document.body.appendChild(globalTooltip);
            return globalTooltip;
        }

        function showConflictTooltip(event, userName, conflictsString) {
            const tooltip = createGlobalTooltip();
            const button = event.target;
            const buttonRect = button.getBoundingClientRect();

            // Parse conflicts string
            const conflicts = conflictsString.split('|||').filter(c => c.length > 0);

            // Set tooltip content
            tooltip.innerHTML = `
                <div class="conflict-popup-content-inner">
                    <div class="conflict-popup-message">
                        ${userName} already assigned to this time slot
                    </div>
                    ${conflicts.map(conflict => `<div class="conflict-popup-session">${conflict}</div>`).join('')}
                </div>
            `;

            // Position tooltip above button, centered, but constrain to viewport
            const tooltipWidth = 300;
            const viewportWidth = window.innerWidth;
            const buttonCenter = buttonRect.left + (buttonRect.width / 2);

            let left = buttonCenter - (tooltipWidth / 2);

            // Keep tooltip within viewport with 10px margin
            if (left < 10) {
                left = 10;
            } else if (left + tooltipWidth > viewportWidth - 10) {
                left = viewportWidth - tooltipWidth - 10;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = (buttonRect.top - tooltip.offsetHeight - 8) + 'px';
            tooltip.style.width = tooltipWidth + 'px';

            // Show tooltip
            tooltip.style.visibility = 'visible';
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateY(0)';
        }

        function hideConflictTooltip() {
            if (globalTooltip) {
                globalTooltip.style.visibility = 'hidden';
                globalTooltip.style.opacity = '0';
                globalTooltip.style.transform = 'translateY(10px)';
            }
        }

        // Duplicate Assignment Modal Functions
        let duplicateAssignmentResolve = null;

        function showDuplicateAssignmentModal(existingMsdName, sessionTitle) {
            return new Promise((resolve) => {
                duplicateAssignmentResolve = resolve;

                // Update modal content
                document.getElementById('existing-msd-name').textContent = existingMsdName;
                document.getElementById('duplicate-session-title').textContent = sessionTitle;

                // Show modal
                document.getElementById('duplicate-assignment-modal').style.display = 'block';
            });
        }

        function confirmDuplicateAssignment() {
            document.getElementById('duplicate-assignment-modal').style.display = 'none';
            if (duplicateAssignmentResolve) {
                duplicateAssignmentResolve(true);
                duplicateAssignmentResolve = null;
            }
        }

        function cancelDuplicateAssignment() {
            document.getElementById('duplicate-assignment-modal').style.display = 'none';
            if (duplicateAssignmentResolve) {
                duplicateAssignmentResolve(false);
                duplicateAssignmentResolve = null;
            }
        }
    </script>

    <!-- Duplicate Assignment Warning Modal -->
    <div id="duplicate-assignment-modal" class="modal">
        <div class="modal-content warning-modal">
            <div class="warning-header">
                <div class="warning-icon">‚ö†Ô∏è</div>
                <h3>DUPLICATE ASSIGNMENT WARNING</h3>
            </div>
            <div class="warning-body">
                <p class="warning-message">
                    This session already has an MSD assigned: <strong id="existing-msd-name">Unknown</strong>
                </p>
                <p class="session-title">
                    Session: <span id="duplicate-session-title">Unknown Session</span>
                </p>
                <p class="warning-note">
                    Typically only one MSD should attend each session (except poster sessions).
                </p>
                <p class="warning-question">
                    Do you want to assign multiple MSDs to this session?
                </p>
            </div>
            <div class="warning-buttons">
                <button class="btn btn-danger" onclick="cancelDuplicateAssignment()">
                    ‚ùå Cancel Assignment
                </button>
                <button class="btn btn-warning" onclick="confirmDuplicateAssignment()">
                    ‚ö†Ô∏è Allow Multiple MSDs
                </button>
            </div>
        </div>
    </div>

</body>
</html>